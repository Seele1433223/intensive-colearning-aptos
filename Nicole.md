---
timezone: Asia/Shanghai
---

# Nicole

1. è‡ªæˆ‘ä»‹ç»
   * å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯Nicoleï¼Œå¯¹äºDefiæ„Ÿå…´è¶£ï¼Œå¸Œæœ›å¯ä»¥getä¸€äº›å‰æ²¿æŠ€æœ¯åœ¨ç©å„¿ä»€ä¹ˆhhã€‚
   
3. ä½ è®¤ä¸ºä½ ä¼šå®Œæˆæœ¬æ¬¡æ®‹é…·å­¦ä¹ å—ï¼Ÿ
   * åŠªåŠ›ï¼

## Notes

<!-- Content_START -->

### 2024.09.07

1. å­¦ä¹ äº†æ®‹é…·å­¦ä¹ çš„å­¦ä¹ ã€æ‰“å¡æ–¹å¼å’Œæœºåˆ¶
2. äº†è§£äº†aptosçš„åŸºç¡€çŸ¥è¯†
* ç¡®è®¤å¼€å‘å·¥å…·ideaä»¥åŠæ’ä»¶Move on Aptos
* æ˜ç¡®äº†å­¦ä¹ èµ„æ–™çš„åœ°å€
  é—®é¢˜æœç´¢åœ°å€ï¼šhttps://github.com/aptos-labs/aptos-developer-discussions/discussions
  
  äº¤æ˜“æŸ¥è¯¢åœ°å€ï¼šhttps://explorer.aptoslabs.com/?network=mainnet

### 2024.09.08

1. å­¦ä¹ é…ç½®å¼€å‘ç¯å¢ƒ
2. æµè§ˆAptosç™½çš®ä¹¦
    Aptos åŒºå—é“¾è®¾è®¡åŸåˆ™ï¼šæ‰©å±•æ€§ã€å®‰å…¨æ€§ã€å¯é æ€§å’Œå¯å‡çº§æ€§ã€‚
  * é¦–å…ˆï¼ŒAptos åŒºå—é“¾åŸç”Ÿé›†æˆå¹¶åœ¨å†…éƒ¨ä½¿ç”¨ Move è¯­è¨€è¿›è¡Œå¿«é€Ÿå’Œå®‰å…¨çš„äº¤æ˜“æ‰§è¡Œã€‚Move éªŒè¯å™¨æ˜¯ä¸€ä¸ªç”¨äºç”¨ Move è¯­è¨€ç¼–å†™çš„æ™ºèƒ½åˆçº¦çš„å½¢å¼éªŒè¯å™¨ï¼Œä¸ºåˆçº¦ä¸å˜é‡å’Œè¡Œä¸ºæä¾›é¢å¤–çš„ä¿éšœã€‚è¿™ç§å¯¹å®‰å…¨çš„å…³æ³¨ä½¿å¼€å‘è€…èƒ½å¤Ÿæ›´å¥½åœ°ä¿æŠ¤ä»–ä»¬çš„è½¯ä»¶å…å—æ¶æ„å®ä½“çš„æ”»å‡»ã€‚
  * å…¶æ¬¡ï¼ŒAptos æ•°æ®æ¨¡å‹æ”¯æŒçµæ´»çš„å¯†é’¥ç®¡ç†å’Œæ··åˆæ‰˜ç®¡é€‰é¡¹ã€‚è¿™ä¸åœ¨ç­¾åå‰çš„äº¤æ˜“é€æ˜åº¦å’Œå®ç”¨çš„è½»å®¢æˆ·ç«¯åè®®ä¸€èµ·ï¼Œæä¾›äº†æ›´å®‰å…¨å’Œæ›´å€¼å¾—ä¿¡èµ–çš„ç”¨æˆ·ä½“éªŒã€‚
  * ç¬¬ä¸‰ï¼Œä¸ºäº†å®ç°é«˜ååé‡å’Œä½å»¶è¿Ÿï¼ŒAptos åŒºå—é“¾åœ¨äº¤æ˜“å¤„ç†çš„å…³é”®é˜¶æ®µé‡‡ç”¨æµæ°´çº¿å’Œæ¨¡å—åŒ–æ–¹æ³•ã€‚å…·ä½“æ¥è¯´ï¼Œäº¤æ˜“ä¼ æ’­ã€å—å…ƒæ•°æ®æ’åºã€å¹¶è¡Œäº¤æ˜“æ‰§è¡Œã€æ‰¹é‡å­˜å‚¨å’Œè´¦æœ¬è®¤è¯éƒ½åŒæ—¶è¿›è¡Œã€‚è¿™ç§æ–¹æ³•å……åˆ†åˆ©ç”¨æ‰€æœ‰å¯ç”¨çš„ç‰©ç†èµ„æºï¼Œæé«˜ç¡¬ä»¶æ•ˆç‡ï¼Œå¹¶å®ç°é«˜åº¦å¹¶è¡Œæ‰§è¡Œã€‚
  * ç¬¬å››ï¼Œä¸å…¶ä»–éœ€è¦é¢„å…ˆçŸ¥é“è¦è¯»å†™çš„æ•°æ®ä»è€Œæ‰“ç ´äº¤æ˜“åŸå­æ€§çš„å¹¶è¡Œæ‰§è¡Œå¼•æ“ä¸åŒï¼ŒAptos åŒºå—é“¾ä¸ä¼šå¯¹å¼€å‘è€…æ–½åŠ è¿™æ ·çš„é™åˆ¶ã€‚å®ƒå¯ä»¥æœ‰æ•ˆåœ°æ”¯æŒä»»æ„å¤æ‚äº¤æ˜“çš„åŸå­æ€§ï¼Œä¸ºå®é™…åº”ç”¨æä¾›æ›´é«˜çš„ååé‡å’Œæ›´ä½çš„å»¶è¿Ÿï¼Œå¹¶ç®€åŒ–å¼€å‘ã€‚
  * ç¬¬äº”ï¼ŒAptos æ¨¡å—åŒ–æ¶æ„è®¾è®¡æ”¯æŒå®¢æˆ·ç«¯çš„çµæ´»æ€§ï¼Œå¹¶é’ˆå¯¹é¢‘ç¹å’Œå³æ—¶å‡çº§è¿›è¡Œäº†ä¼˜åŒ–ã€‚æ­¤å¤–ï¼Œä¸ºäº†å¿«é€Ÿéƒ¨ç½²æ–°æŠ€æœ¯åˆ›æ–°å¹¶æ”¯æŒæ–°çš„ Web3 ç”¨ä¾‹ï¼ŒAptos åŒºå—é“¾æä¾›äº†åµŒå…¥å¼é“¾ä¸Šå˜æ›´ç®¡ç†åè®®ã€‚æœ€åï¼ŒAptos åŒºå—é“¾æ­£åœ¨è¯•éªŒæœªæ¥çš„ä¸¾æªï¼Œä»¥è¶…è¶Šå•ä¸ªéªŒè¯å™¨çš„æ€§èƒ½è¿›è¡Œæ‰©å±•ï¼šå…¶æ¨¡å—åŒ–è®¾è®¡å’Œå¹¶è¡Œæ‰§è¡Œå¼•æ“æ”¯æŒéªŒè¯å™¨çš„å†…éƒ¨åˆ†ç‰‡ï¼ŒåŒè´¨çŠ¶æ€åˆ†ç‰‡ä¸ºæ°´å¹³ååé‡å¯æ‰©å±•æ€§æä¾›äº†æ½œåŠ›ï¼Œè€Œä¸ä¼šç»™èŠ‚ç‚¹è¿è¥å•†å¢åŠ é¢å¤–çš„å¤æ‚æ€§ã€‚
   
### 2024.09.09

1. Aptos èŠ‚ç‚¹æ˜¯ Aptos ç”Ÿæ€ç³»ç»Ÿçš„ä¸€ä¸ªå®ä½“ï¼Œç”¨äºè·Ÿè¸ª Aptos åŒºå—é“¾çš„çŠ¶æ€ã€‚å®¢æˆ·ç«¯é€šè¿‡ Aptos èŠ‚ç‚¹ä¸åŒºå—é“¾äº¤äº’ã€‚æœ‰ä¸¤ç§ç±»å‹çš„èŠ‚ç‚¹ï¼š
* Validator nodes éªŒè¯èŠ‚ç‚¹
* Fullnodes å…¨èŠ‚ç‚¹
** æ¯ä¸ªAptosèŠ‚ç‚¹éƒ½åŒ…æ‹¬å‡ ä¸ªé€»è¾‘ç»„ä»¶
  REST API service
  Mempool
  Execution
  Virtual Machine
  Storage
  State synchronize çŠ¶æ€åŒæ­¥å™¨
##### è®¨è®ºåŒºèµ„æ–™è¡¥å……ï¼šhttps://github.com/aptos-labs/aptos-developer-discussions/discussions

### 2024.09.10

1. äº¤æ˜“ä»æ„å»ºåˆ°é“¾ä¸Šæ‰§è¡Œéœ€è¦ç»å†5ä¸ªæ­¥éª¤ï¼šæ„å»ºã€æ¨¡æ‹Ÿã€ç­¾åã€æäº¤ã€ç­‰å¾…ã€‚
2. èŠ‚ç‚¹ç½‘ç»œå’ŒåŒæ­¥ï¼šéªŒè¯å™¨èŠ‚ç‚¹å’Œå…¨èŠ‚ç‚¹å½¢æˆå±‚æ¬¡ç»“æ„ï¼ŒéªŒè¯å™¨èŠ‚ç‚¹ä½äºæ ¹ï¼Œå…¨èŠ‚ç‚¹ä½äºå…¶ä»–ä½ç½®ã€‚éªŒè¯å™¨å…¨èŠ‚ç‚¹ç›´æ¥è¿æ¥åˆ°éªŒè¯å™¨èŠ‚ç‚¹ï¼Œå¹¶æä¾›å¯æ‰©å±•æ€§å’Œ DDoS ç¼“è§£åŠŸèƒ½ã€‚å…¬å…±å…¨èŠ‚ç‚¹è¿æ¥åˆ°éªŒè¯å™¨å…¨èŠ‚ç‚¹ï¼ˆæˆ–å…¶ä»–å…¬å…±å…¨èŠ‚ç‚¹ï¼‰ä»¥è·å¾—å¯¹ Aptos ç½‘ç»œçš„ä½å»¶è¿Ÿè®¿é—®ã€‚
3. Move æ˜¯ä¸€ç§å®‰å…¨å¯é çš„ Web3 ç¼–ç¨‹è¯­è¨€ï¼Œå¼ºè°ƒç¨€ç¼ºæ€§å’Œè®¿é—®æ§åˆ¶ã€‚ Move ä¸­çš„ä»»ä½•èµ„äº§éƒ½å¯ä»¥ç”± resources è¡¨ç¤ºæˆ–å­˜å‚¨åœ¨resourcesä¸­ã€‚é»˜è®¤æƒ…å†µä¸‹ä¼šå¼ºåˆ¶å®æ–½ç¨€ç¼ºæ€§ï¼Œå› ä¸ºç»“æ„ä¸ä¼šè¢«æ„å¤–å¤åˆ¶æˆ–åˆ é™¤ã€‚åªæœ‰åœ¨å­—èŠ‚ç å±‚æ˜ç¡®å®šä¹‰ä¸ºcopy çš„ç»“æ„æ‰å¯ä»¥åˆ†åˆ«è¢«å¤åˆ¶å’Œdrop ã€‚
4. äº¤æ˜“å’ŒçŠ¶æ€ï¼š
   * äº¤æ˜“ï¼šäº¤æ˜“ä»£è¡¨åŒºå—é“¾ä¸Šçš„è´¦æˆ·æ‰§è¡Œçš„é¢„æœŸæ“ä½œï¼ˆä¾‹å¦‚ï¼Œè½¬ç§»èµ„äº§ï¼‰ã€‚ï¼ˆåªæœ‰äº¤æ˜“æ‰èƒ½æ”¹å˜è´¦æœ¬çŠ¶æ€ï¼‰
   * çŠ¶æ€ï¼šï¼ˆåŒºå—é“¾è´¦æœ¬ï¼‰çŠ¶æ€ä»£è¡¨äº¤æ˜“æ‰§è¡Œè¾“å‡ºçš„ç´¯ç§¯ï¼Œå³å­˜å‚¨åœ¨æ‰€æœ‰èµ„æºä¸­çš„å€¼ã€‚
   * äº‹ä»¶ï¼šæ‰§è¡Œäº¤æ˜“æ—¶å‘å¸ƒçš„è¾…åŠ©æ•°æ®ã€‚


### 2024.09.11

### 2024.09.12
1. åŒºå—ï¼š
   - Aptos æ˜¯ä¸€ä¸ªæŒ‰äº¤æ˜“ç‰ˆæœ¬æ§åˆ¶çš„æ•°æ®åº“ã€‚æ‰§è¡Œäº¤æ˜“æ—¶ï¼Œæ¯ç¬”äº¤æ˜“çš„ç»“æœçŠ¶æ€éƒ½ä¼šå•ç‹¬å­˜å‚¨ï¼Œä»è€Œå…è®¸æ›´ç²¾ç»†çš„æ•°æ®è®¿é—®ã€‚è¿™ä¸å…¶ä»–åŒºå—é“¾ä¸åŒï¼Œå…¶ä»–åŒºå—é“¾åªå­˜å‚¨åŒºå—ï¼ˆä¸€ç»„äº¤æ˜“ï¼‰çš„ç»“æœçŠ¶æ€ã€‚
   - åŒºå—ä»ç„¶æ˜¯ Aptos çš„åŸºæœ¬å•ä½ã€‚äº¤æ˜“è¢«åˆ†æ‰¹å¤„ç†å¹¶åœ¨ä¸€ä¸ªåŒºå—ä¸­ä¸€èµ·æ‰§è¡Œã€‚æ­¤å¤–ï¼Œå­˜å‚¨ä¸­çš„è¯æ˜å¤„äºåŒºå—çº§ç²’åº¦ã€‚åŒºå—å†…çš„äº¤æ˜“æ•°é‡å–å†³äºç½‘ç»œæ´»åŠ¨å’Œå¯é…ç½®çš„æœ€å¤§åŒºå—å¤§å°é™åˆ¶ã€‚
2. è´¨æŠ¼ï¼šä»»ä½•äººéƒ½å¯ä»¥å‚ä¸ Aptos å…±è¯†è¿‡ç¨‹ï¼Œåªè¦ä»–ä»¬è´¨æŠ¼äº†è¶³å¤Ÿçš„å®ç”¨å¸ï¼Œå³å°†ä»–ä»¬çš„å®ç”¨å¸å­˜å…¥æ‰˜ç®¡è´¦æˆ·ã€‚ä¸ºäº†é¼“åŠ±éªŒè¯è€…å‚ä¸å…±è¯†è¿‡ç¨‹ï¼Œæ¯ä¸ªéªŒè¯è€…çš„æŠ•ç¥¨æƒé‡ä¸éªŒè¯è€…çš„è´¨æŠ¼é‡‘é¢æˆæ­£æ¯”ã€‚ä½œä¸ºäº¤æ¢ï¼ŒéªŒè¯è€…å°†æŒ‰è´¨æŠ¼é‡‘é¢çš„æ¯”ä¾‹è·å¾—å¥–åŠ±ã€‚å› æ­¤ï¼ŒåŒºå—é“¾çš„æ€§èƒ½ä¸éªŒè¯è€…çš„åˆ©ç›Šï¼ˆå³å¥–åŠ±ï¼‰ä¿æŒä¸€è‡´ã€‚
   - Owner
   - Operator
   - Voter
4. Aptos ä¸»ç½‘çºªå…ƒè®¾ç½®ä¸º 7200 ç§’ï¼ˆä¸¤å°æ—¶ï¼‰ã€‚
5. å¥–åŠ±å…¬å¼
```text
    Reward = staked_amount * rewards_rate per epoch * (Number of successful proposals by the validator / Total number of proposals made by the validator) 
```
### 2024.09.13
- è¾¹å­¦è¾¹å¿˜ğŸ¤¦ï¼Œç®€å•å¤ä¹ äº†ä¸€ä¸‹æœ€åˆçš„ç›´æ’­å†…å®¹
- ä¸‹å‘¨å¤šæŠ½æ—¶é—´æ¥ç ”ç©¶

### 2024.09.14
è¡¥å……
### 2024.09.15
1. å®‰è£…Aptos CLI
2. Create package
 - aptos move init
   - aptos move init --name <PROJECT_NAME>
 - Update Move.toml
```
[package]
name = "Examples"
version = "0.0.0"
 
[addresses]
hello_blockchain = "_"
 
[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "mainnet"
subdir = "aptos-move/framework/aptos-framework"
```
 - Add to sources directory
   - https://github.com/aptos-labs/aptos-core/tree/afd3706c17bcccfb39a9d6059aecbfa648ed295d/aptos-move/move-examples

### 2024.09.16

### 2024.09.17
ä¸­ç§‹èŠ‚å¿«ä¹ï¼

### 2024.09.18
å‚åŠ ä¼šè®®ï¼šæ„å»ºå¹¶éƒ¨ç½²ä»£å¸æ°´é¾™å¤´

### 2024.09.19
åœ¨ Aptos åŒºå—é“¾ä¸Šåˆ›å»º NFT å¸‚åœº
1. Listing NFTs: NFT owners list their NFTs in the marketplace, making them available for potential buyers to purchase.
2. Buying NFTs: Users can buy any NFT listed with the price set by the NFT owner.
3. Minting NFTs: For the demo purpose, we also built a Mint feature where you can mint NFTs to sell.
```
module marketplace_addr::marketplace {
    use std::error;
    use std::signer;
    use std::option;
    use aptos_std::smart_vector;
    use aptos_framework::aptos_account;
    use aptos_framework::coin;
    use aptos_framework::object;

    #[test_only]
    friend marketplace_addr::test_marketplace;

    const APP_OBJECT_SEED: vector<u8> = b"MARKETPLACE";

    /// There exists no listing.
    const ENO_LISTING: u64 = 1;
    /// There exists no seller.
    const ENO_SELLER: u64 = 2;

    // Core data structures

    struct MarketplaceSigner has key {
        extend_ref: object::ExtendRef,
    }

    // In production we should use off-chain indexer to store all sellers instead of storing them on-chain.
    // Storing it on-chain is costly since it's O(N) to remove a seller.
    struct Sellers has key {
        /// All addresses of sellers.
        addresses: smart_vector::SmartVector<address>
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct Listing has key {
        /// The item owned by this listing, transferred to the new owner at the end.
        object: object::Object<object::ObjectCore>,
        /// The seller of the object.
        seller: address,
        /// Used to clean-up at the end.
        delete_ref: object::DeleteRef,
        /// Used to create a signer to transfer the listed item, ideally the TransferRef would support this.
        extend_ref: object::ExtendRef,
    }

    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    struct FixedPriceListing<phantom CoinType> has key {
        /// The price to purchase the item up for listing.
        price: u64,
    }

    // In production we should use off-chain indexer to store the listings of a seller instead of storing it on-chain.
    // Storing it on-chain is costly since it's O(N) to remove a listing.
    struct SellerListings has key {
        /// All object addresses of listings the user has created.
        listings: smart_vector::SmartVector<address>
    }

    // Functions

    // This function is only called once when the module is published for the first time.
    fun init_module(deployer: &signer) {
        let constructor_ref = object::create_named_object(
            deployer,
            APP_OBJECT_SEED,
        );
        let extend_ref = object::generate_extend_ref(&constructor_ref);
        let marketplace_signer = &object::generate_signer(&constructor_ref);

        move_to(marketplace_signer, MarketplaceSigner {
            extend_ref,
        });
    }

    // ================================= Entry Functions ================================= //

    /// List an time for sale at a fixed price.
    public entry fun list_with_fixed_price<CoinType>(
        seller: &signer,
        object: object::Object<object::ObjectCore>,
        price: u64,
    ) acquires SellerListings, Sellers, MarketplaceSigner {
        list_with_fixed_price_internal<CoinType>(seller, object, price);
    }

    /// Purchase outright an item from a fixed price listing.
    public entry fun purchase<CoinType>(
        purchaser: &signer,
        object: object::Object<object::ObjectCore>,
    ) acquires FixedPriceListing, Listing, SellerListings, Sellers {
        let listing_addr = object::object_address(&object);

        assert!(exists<Listing>(listing_addr), error::not_found(ENO_LISTING));
        assert!(exists<FixedPriceListing<CoinType>>(listing_addr), error::not_found(ENO_LISTING));

        let FixedPriceListing {
            price,
        } = move_from<FixedPriceListing<CoinType>>(listing_addr);

        // The listing has concluded, transfer the asset and delete the listing. Returns the seller
        // for depositing any profit.

        let coins = coin::withdraw<CoinType>(purchaser, price);

        let Listing {
            object,
            seller, // get seller from Listing object
            delete_ref,
            extend_ref,
        } = move_from<Listing>(listing_addr);

        let obj_signer = object::generate_signer_for_extending(&extend_ref);
        object::transfer(&obj_signer, object, signer::address_of(purchaser));
        object::delete(delete_ref); // Clean-up the listing object.

        // Note this step of removing the listing from the seller's listings will be costly since it's O(N).
        // Ideally you don't store the listings in a vector but in an off-chain indexer
        let seller_listings = borrow_global_mut<SellerListings>(seller);
        let (exist, idx) = smart_vector::index_of(&seller_listings.listings, &listing_addr);
        assert!(exist, error::not_found(ENO_LISTING));
        smart_vector::remove(&mut seller_listings.listings, idx);

        if (smart_vector::length(&seller_listings.listings) == 0) {
            // If the seller has no more listings, remove the seller from the marketplace.
            let sellers = borrow_global_mut<Sellers>(get_marketplace_signer_addr());
            let (exist, idx) = smart_vector::index_of(&sellers.addresses, &seller);
            assert!(exist, error::not_found(ENO_SELLER));
            smart_vector::remove(&mut sellers.addresses, idx);
        };

        aptos_account::deposit_coins(seller, coins);
    }

    // ================================= Friend Functions ================================= //

    public(friend) fun list_with_fixed_price_internal<CoinType>(
        seller: &signer,
        object: object::Object<object::ObjectCore>,
        price: u64,        
    ): object::Object<Listing> acquires SellerListings, Sellers, MarketplaceSigner {
        let constructor_ref = object::create_object(signer::address_of(seller));

        let transfer_ref = object::generate_transfer_ref(&constructor_ref);
        object::disable_ungated_transfer(&transfer_ref);

        let listing_signer = object::generate_signer(&constructor_ref);

        let listing = Listing {
            object,
            seller: signer::address_of(seller),
            delete_ref: object::generate_delete_ref(&constructor_ref),
            extend_ref: object::generate_extend_ref(&constructor_ref),
        };
        let fixed_price_listing = FixedPriceListing<CoinType> {
            price,
        };
        move_to(&listing_signer, listing);
        move_to(&listing_signer, fixed_price_listing);

        object::transfer(seller, object, signer::address_of(&listing_signer));

        let listing = object::object_from_constructor_ref(&constructor_ref);

        if (exists<SellerListings>(signer::address_of(seller))) {
            let seller_listings = borrow_global_mut<SellerListings>(signer::address_of(seller));
            smart_vector::push_back(&mut seller_listings.listings, object::object_address(&listing));
        } else {
            let seller_listings = SellerListings {
                listings: smart_vector::new(),
            };
            smart_vector::push_back(&mut seller_listings.listings, object::object_address(&listing));
            move_to(seller, seller_listings);
        };
        if (exists<Sellers>(get_marketplace_signer_addr())) {
            let sellers = borrow_global_mut<Sellers>(get_marketplace_signer_addr());
            if (!smart_vector::contains(&sellers.addresses, &signer::address_of(seller))) {
                smart_vector::push_back(&mut sellers.addresses, signer::address_of(seller));
            }
        } else {
            let sellers = Sellers {
                addresses: smart_vector::new(),
            };
            smart_vector::push_back(&mut sellers.addresses, signer::address_of(seller));
            move_to(&get_marketplace_signer(get_marketplace_signer_addr()), sellers);
        };

        listing
    }

    // View functions

    #[view]
    public fun price<CoinType>(
        object: object::Object<Listing>,
    ): option::Option<u64> acquires FixedPriceListing {
        let listing_addr = object::object_address(&object);
        if (exists<FixedPriceListing<CoinType>>(listing_addr)) {
            let fixed_price = borrow_global<FixedPriceListing<CoinType>>(listing_addr);
            option::some(fixed_price.price)
        } else {
            // This should just be an abort but the compiler errors.
            assert!(false, error::not_found(ENO_LISTING));
            option::none()
        }
    }

    #[view]
    public fun listing(object: object::Object<Listing>): (object::Object<object::ObjectCore>, address) acquires Listing {
        let listing = borrow_listing(object);
        (listing.object, listing.seller)
    }

    #[view]
    public fun get_seller_listings(seller: address): vector<address> acquires SellerListings {
        if (exists<SellerListings>(seller)) {
            smart_vector::to_vector(&borrow_global<SellerListings>(seller).listings)
        } else {
            vector[]
        }
    }

    #[view]
    public fun get_sellers(): vector<address> acquires Sellers {
        if (exists<Sellers>(get_marketplace_signer_addr())) {
            smart_vector::to_vector(&borrow_global<Sellers>(get_marketplace_signer_addr()).addresses)
        } else {
            vector[]
        }
    }

    #[test_only]
    public fun setup_test(marketplace: &signer) {
        init_module(marketplace);
    }

    // Helper functions

    fun get_marketplace_signer_addr(): address {
        object::create_object_address(&@marketplace_addr, APP_OBJECT_SEED)
    }

    fun get_marketplace_signer(marketplace_signer_addr: address): signer acquires MarketplaceSigner {
        object::generate_signer_for_extending(&borrow_global<MarketplaceSigner>(marketplace_signer_addr).extend_ref)
    }

    inline fun borrow_listing(object: object::Object<Listing>): &Listing acquires Listing {
        let obj_addr = object::object_address(&object);
        assert!(exists<Listing>(obj_addr), error::not_found(ENO_LISTING));
        borrow_global<Listing>(obj_addr)
    }
}

// Unit tests

#[test_only]
module marketplace_addr::test_marketplace {
    use std::option;
    use aptos_framework::aptos_coin;
    use aptos_framework::coin;
    use aptos_framework::object;
    use aptos_token_objects::token;
    use marketplace_addr::marketplace;
    use marketplace_addr::test_utils;

    // Test that a fixed price listing can be created and purchased.
    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]
    fun test_fixed_price(
        aptos_framework: &signer,
        marketplace: &signer,
        seller: &signer,
        purchaser: &signer,
    ) {
        let (_marketplace_addr, seller_addr, purchaser_addr) =
            test_utils::setup(aptos_framework, marketplace, seller, purchaser);

        let (token, listing) = fixed_price_listing(seller, 500); // price: 500

        let (listing_obj, seller_addr2) = marketplace::listing(listing);
        assert!(listing_obj == object::convert(token), 0); // The token is listed.
        assert!(seller_addr2 == seller_addr, 0); // The seller is the owner of the listing.
        assert!(marketplace::price<aptos_coin::AptosCoin>(listing) == option::some(500), 0); // The price is 500.
        assert!(object::owner(token) == object::object_address(&listing), 0); // The token is owned by the listing object. (escrowed)

        marketplace::purchase<aptos_coin::AptosCoin>(purchaser, object::convert(listing));

        assert!(object::owner(token) == purchaser_addr, 0); // The token has been transferred to the purchaser.
        assert!(coin::balance<aptos_coin::AptosCoin>(seller_addr) == 10500, 0); // The seller has been paid.
        assert!(coin::balance<aptos_coin::AptosCoin>(purchaser_addr) == 9500, 0); // The purchaser has paid.
    }

    // Test that the purchase fails if the purchaser does not have enough coin.
    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]
    #[expected_failure(abort_code = 0x10006, location = aptos_framework::coin)]
    fun test_not_enough_coin_fixed_price(
        aptos_framework: &signer,
        marketplace: &signer,
        seller: &signer,
        purchaser: &signer,
    ) {
        test_utils::setup(aptos_framework, marketplace, seller, purchaser);

        let (_token, listing) = fixed_price_listing(seller, 100000); // price: 100000

        marketplace::purchase<aptos_coin::AptosCoin>(purchaser, object::convert(listing));
    }

    // Test that the purchase fails if the listing object does not exist.
    #[test(aptos_framework = @0x1, marketplace = @0x111, seller = @0x222, purchaser = @0x333)]
    #[expected_failure(abort_code = 0x60001, location = marketplace_addr::marketplace)]
    fun test_no_listing(
        aptos_framework: &signer,
        marketplace: &signer,
        seller: &signer,
        purchaser: &signer,
    ) {
        let (_, seller_addr, _) = test_utils::setup(aptos_framework, marketplace, seller, purchaser);

        let dummy_constructor_ref = object::create_object(seller_addr);
        let dummy_object = object::object_from_constructor_ref<object::ObjectCore>(&dummy_constructor_ref);

        marketplace::purchase<aptos_coin::AptosCoin>(purchaser, object::convert(dummy_object));
    }


    inline fun fixed_price_listing(
        seller: &signer,
        price: u64
    ): (object::Object<token::Token>, object::Object<marketplace::Listing>) {
        let token = test_utils::mint_tokenv2(seller);
        fixed_price_listing_with_token(seller, token, price)
    }

    inline fun fixed_price_listing_with_token(
        seller: &signer,
        token: object::Object<token::Token>,
        price: u64
    ): (object::Object<token::Token>, object::Object<marketplace::Listing>) {
        let listing = marketplace::list_with_fixed_price_internal<aptos_coin::AptosCoin>(
            seller,
            object::convert(token), // Object<Token> -> Object<ObjectCore>
            price,
        );
        (token, listing)
    }
}
```

### 2024.09.20

1. Aptos keyless
  Aptos Keyless å…è®¸ç”¨æˆ·ä»ç°æœ‰çš„ OpenID Connect (OIDC) å¸æˆ·ï¼ˆä¾‹å¦‚ï¼Œä½¿ç”¨ Google ç™»å½•ï¼›ä½¿ç”¨ Apple ç™»å½•ï¼‰è·å¾— Aptos åŒºå—é“¾å¸æˆ·çš„æ‰€æœ‰æƒï¼Œè€Œä¸æ˜¯é€šè¿‡ä¼ ç»Ÿçš„å¯†é’¥æˆ–åŠ©è®°è¯ã€‚
  Aptos Keyless é¢„æœŸçš„å®‰å…¨æ¨¡å‹æ˜¯â€œåŒºå—é“¾è´¦æˆ·=è°·æ­Œè´¦æˆ·â€ã€‚å¦‚æœè°·æ­Œè´¦æˆ·å­˜åœ¨é£é™©ï¼Œåˆ™åŒºå—é“¾è´¦æˆ·ä¹Ÿç­‰åŒã€‚

### 2024.09.21

### 2024.09.22

### 2024.09.23
<!-- Content_END -->
